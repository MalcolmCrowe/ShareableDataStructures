Finder for SqlUpdate is bottom-up or top-down?
Generally finder enables RowSet to explain how to look up a value by uid: mostly entries are in sources.
Some entries come from the left of the rowset (lateral reference)

QuerySearch.Obey
            Level cl = cx.db.user?.clearance ?? Level.D;
                if (ob is Table ta && cx.db.user != null && cx.db.user.defpos != cx.db.owner
                    && ta.enforcement.HasFlag(Grant.Privilege.Delete)
                    && !cl.ClearanceAllows(ta.classification))
                    throw new DBException("42105");
UpdateSearch.Obey
            Level cl = cx.db.user?.clearance ?? Level.D;
                if (ob is Table ta && cx.db.user != null && cx.db.user.defpos != cx.db.owner
                    && ta.enforcement.HasFlag(Grant.Privilege.Update)
                    && !cl.ClearanceAllows(ta.classification))
                    throw new DBException("42105");
SqlInsert.Obey
            Level cl = cx.db.user?.clearance ?? Level.D;
                if (ob is Table ta && cx.db.user != null && cx.db.user.defpos != cx.db.owner
                    && ta.enforcement.HasFlag(Grant.Privilege.Insert)
                    && !cl.ClearanceAllows(ta.classification))
                    throw new DBException("42105");
VirtTable
        internal override Context Insert(Context cx, RowSet fm, string prov, Level cl)
        {
            var rrs = (RestRowSet)fm;
            for (var trb = fm.First(cx); trb != null; trb = trb.Next(cx))
            {
                var r = cx.db.nextPos;
                var rc = new RemoteTableRow(defpos, trb.values,"",rrs);
                var st = rc.subType;
                var np = cx.db.nextPos;
                rc._Insert(cx, np, trb.values, st, prov, cl);
            }
            cx.result = -1L;
            return cx;
        }

        internal override Context Update(Context cx, RowSet fm)
        {
            if (fm.assig.Count == 0)
                return cx;
            var updates = BTree<long, UpdateAssignment>.Empty;
            for (var ass = fm.assig.First(); ass != null; ass = ass.Next())
            {
                var c = cx.obs[ass.key().vbl] as SqlCopy
                    ?? throw new DBException("0U000");
                DBObject oc = c;
                while (oc is SqlCopy sc) // Views have indirection here
                    oc = cx.obs[sc.copyFrom];
                updates += (oc.defpos, ass.key());
            }
            cx.finder += fm.finder;
            if (updates.Count > 0)
                for (var trb = fm.First(cx); trb != null; trb = trb.Next(cx))
                {
                    for (var b = updates.First(); b != null; b = b.Next())
                    {
                        var ua = b.value();
                        var tv = cx.obs[ua.val].Eval(cx);
                        trb += (cx, ua.vbl, tv);
                    }
                    var rc = trb.Rec()[0];
                    var np = cx.db.nextPos;
                    var vs = trb.values;
                    if (vs.CompareTo(rc.vals) == 0)
                        continue;
                    var nr = rc._Update(cx, np, vs, null);
                }
            cx.result = -1L; //??
            return cx;
        }